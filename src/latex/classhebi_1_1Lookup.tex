\hypertarget{classhebi_1_1Lookup}{}\section{hebi\+:\+:Lookup Class Reference}
\label{classhebi_1_1Lookup}\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}}


Maintains a registry of network-\/connected modules and returns \hyperlink{classhebi_1_1Module}{Module} and \hyperlink{classhebi_1_1Group}{Group} objects to the user.  




{\ttfamily \#include $<$lookup.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classhebi_1_1Lookup_acdfa87d652dd197ff578e5ea0f25128c}{Lookup} ()
\begin{DoxyCompactList}\small\item\em Creates a \hyperlink{classhebi_1_1Lookup}{Lookup} object which can create \hyperlink{classhebi_1_1Module}{Module} and \hyperlink{classhebi_1_1Group}{Group} references. Typically, only one \hyperlink{classhebi_1_1Lookup}{Lookup} object should exist at a time. \end{DoxyCompactList}\item 
virtual \hyperlink{classhebi_1_1Lookup_a7d9e38f258c85bedfd63c71c41d1bd8b}{$\sim$\+Lookup} () noexcept\hypertarget{classhebi_1_1Lookup_a7d9e38f258c85bedfd63c71c41d1bd8b}{}\label{classhebi_1_1Lookup_a7d9e38f258c85bedfd63c71c41d1bd8b}

\begin{DoxyCompactList}\small\item\em Destructor frees all resources created by \hyperlink{classhebi_1_1Lookup}{Lookup} object, and stops the background query thread. \end{DoxyCompactList}\item 
void \hyperlink{classhebi_1_1Lookup_a52e3d10c45ac8b6c47a7944fee1d7189}{print\+Table} ()
\begin{DoxyCompactList}\small\item\em Displays the current contents of the module registry on stdout -- i.\+e., which modules have been found by the lookup. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Module}{Module} $>$ \hyperlink{classhebi_1_1Lookup_aaee883fe7e060f0ea0638a09bc49f54b}{get\+Module\+From\+Name} (const std\+::string \&name, const std\+::string \&family, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a module with the given name and family. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Module}{Module} $>$ \hyperlink{classhebi_1_1Lookup_ad4078193d720554b57bfd47a46d35231}{get\+Module\+From\+Mac} (const \hyperlink{classhebi_1_1MacAddress}{Mac\+Address} \&address, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a module with the given mac address. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Group}{Group} $>$ \hyperlink{classhebi_1_1Lookup_adae9314e23d17ad53e26f146f4c256bf}{get\+Group\+From\+Names} (const std\+::vector$<$ std\+::string $>$ \&names, const std\+::vector$<$ std\+::string $>$ \&families, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a group from modules with the given names and families. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Group}{Group} $>$ \hyperlink{classhebi_1_1Lookup_aad6bf0015b82dbce0b4dde06e1b10f52}{get\+Group\+From\+Macs} (const std\+::vector$<$ \hyperlink{classhebi_1_1MacAddress}{Mac\+Address} $>$ \&addresses, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a group from modules with the given mac addresses. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Group}{Group} $>$ \hyperlink{classhebi_1_1Lookup_a61243d9e23909ecc5511258452d4396f}{get\+Group\+From\+Family} (const std\+::string \&family, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a group from all known modules with the given family. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Group}{Group} $>$ \hyperlink{classhebi_1_1Lookup_afb22de42b4310292bd9a0a5848e3f3e6}{get\+Connected\+Group\+From\+Name} (const std\+::string \&name, const std\+::string \&family, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a group from all modules known to connect to a module with the given name and family. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classhebi_1_1Group}{Group} $>$ \hyperlink{classhebi_1_1Lookup_ad77bc157e336ee526157d5b31eb6bc22}{get\+Connected\+Group\+From\+Mac} (const \hyperlink{classhebi_1_1MacAddress}{Mac\+Address} \&address, long timeout\+\_\+ms=D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+UT)
\begin{DoxyCompactList}\small\item\em Get a group from all modules known to connect to a module with the given mac address. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Maintains a registry of network-\/connected modules and returns \hyperlink{classhebi_1_1Module}{Module} and \hyperlink{classhebi_1_1Group}{Group} objects to the user. 

Only one \hyperlink{classhebi_1_1Lookup}{Lookup} object is needed per application.

\begin{DoxyAuthor}{Author}
Matthew Tesch $<$ matt @ hebirobotics.\+com $>$ 
\end{DoxyAuthor}
\begin{DoxySince}{Since}
18 Feb 2016 
\end{DoxySince}


\subsection{Constructor \& Destructor Documentation}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{Lookup()}{Lookup()}}]{\setlength{\rightskip}{0pt plus 5cm}hebi\+::\+Lookup\+::\+Lookup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_acdfa87d652dd197ff578e5ea0f25128c}{}\label{classhebi_1_1Lookup_acdfa87d652dd197ff578e5ea0f25128c}


Creates a \hyperlink{classhebi_1_1Lookup}{Lookup} object which can create \hyperlink{classhebi_1_1Module}{Module} and \hyperlink{classhebi_1_1Group}{Group} references. Typically, only one \hyperlink{classhebi_1_1Lookup}{Lookup} object should exist at a time. 

Note that this call invokes a background thread to query the network for modules at regular intervals. 

\subsection{Member Function Documentation}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Connected\+Group\+From\+Mac@{get\+Connected\+Group\+From\+Mac}}
\index{get\+Connected\+Group\+From\+Mac@{get\+Connected\+Group\+From\+Mac}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Connected\+Group\+From\+Mac(const Mac\+Address \&address, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getConnectedGroupFromMac(const MacAddress &address, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Group} $>$ hebi\+::\+Lookup\+::get\+Connected\+Group\+From\+Mac (
\begin{DoxyParamCaption}
\item[{const {\bf Mac\+Address} \&}]{address, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_ad77bc157e336ee526157d5b31eb6bc22}{}\label{classhebi_1_1Lookup_ad77bc157e336ee526157d5b31eb6bc22}


Get a group from all modules known to connect to a module with the given mac address. 

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Group}{Group} object with the given parameters. Times out after timeout\+\_\+msec milliseconds.


\begin{DoxyParams}{Parameters}
{\em address} & Physical mac address of the module to form the group from. \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a group is found, and a value of 0 returns immediately if no group with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no group found in allotted time, or reference to a newly allocated group object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Connected\+Group\+From\+Name@{get\+Connected\+Group\+From\+Name}}
\index{get\+Connected\+Group\+From\+Name@{get\+Connected\+Group\+From\+Name}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Connected\+Group\+From\+Name(const std\+::string \&name, const std\+::string \&family, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getConnectedGroupFromName(const std::string &name, const std::string &family, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Group} $>$ hebi\+::\+Lookup\+::get\+Connected\+Group\+From\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{const std\+::string \&}]{family, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_afb22de42b4310292bd9a0a5848e3f3e6}{}\label{classhebi_1_1Lookup_afb22de42b4310292bd9a0a5848e3f3e6}


Get a group from all modules known to connect to a module with the given name and family. 

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Group}{Group} object with the given parameters. Times out after timeout\+\_\+msec milliseconds.


\begin{DoxyParams}{Parameters}
{\em name} & The given name of the module, as viewable in the H\+E\+BI G\+UI, to form the group from. \\
\hline
{\em family} & The given family of the module, as viewable in the H\+E\+BI G\+UI, to form the group from. \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a group is found, and a value of 0 returns immediately if no group with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no group found in allotted time, or reference to a newly allocated group object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Group\+From\+Family@{get\+Group\+From\+Family}}
\index{get\+Group\+From\+Family@{get\+Group\+From\+Family}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Group\+From\+Family(const std\+::string \&family, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getGroupFromFamily(const std::string &family, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Group} $>$ hebi\+::\+Lookup\+::get\+Group\+From\+Family (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{family, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_a61243d9e23909ecc5511258452d4396f}{}\label{classhebi_1_1Lookup_a61243d9e23909ecc5511258452d4396f}


Get a group from all known modules with the given family. 

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Group}{Group} object with the given parameters. Times out after timeout\+\_\+msec milliseconds.


\begin{DoxyParams}{Parameters}
{\em family} & The family of each of the desired group modules. \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a group is found, and a value of 0 returns immediately if no group with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no group found in allotted time, or reference to a newly allocated group object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Group\+From\+Macs@{get\+Group\+From\+Macs}}
\index{get\+Group\+From\+Macs@{get\+Group\+From\+Macs}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Group\+From\+Macs(const std\+::vector$<$ Mac\+Address $>$ \&addresses, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getGroupFromMacs(const std::vector< MacAddress > &addresses, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Group} $>$ hebi\+::\+Lookup\+::get\+Group\+From\+Macs (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf Mac\+Address} $>$ \&}]{addresses, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_aad6bf0015b82dbce0b4dde06e1b10f52}{}\label{classhebi_1_1Lookup_aad6bf0015b82dbce0b4dde06e1b10f52}


Get a group from modules with the given mac addresses. 

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Group}{Group} object with the given parameters. Times out after timeout\+\_\+msec milliseconds.


\begin{DoxyParams}{Parameters}
{\em addresses} & List of physical mac addresses for desired group modules. \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a group is found, and a value of 0 returns immediately if no group with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no group found in allotted time, or reference to a newly allocated group object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Group\+From\+Names@{get\+Group\+From\+Names}}
\index{get\+Group\+From\+Names@{get\+Group\+From\+Names}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Group\+From\+Names(const std\+::vector$<$ std\+::string $>$ \&names, const std\+::vector$<$ std\+::string $>$ \&families, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getGroupFromNames(const std::vector< std::string > &names, const std::vector< std::string > &families, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Group} $>$ hebi\+::\+Lookup\+::get\+Group\+From\+Names (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{names, }
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{families, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_adae9314e23d17ad53e26f146f4c256bf}{}\label{classhebi_1_1Lookup_adae9314e23d17ad53e26f146f4c256bf}


Get a group from modules with the given names and families. 

If one of the input vectors is of length one, then that element is assumed to pair with each item in the other input vector.

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Group}{Group} object with the given parameters. Times out after timeout\+\_\+msec milliseconds.


\begin{DoxyParams}{Parameters}
{\em names} & A list of names of desired group modules, as viewable in the H\+E\+BI G\+UI. If of length one, this name is paired with each given family \\
\hline
{\em families} & A list of families of desired group modules, as viewable in the H\+E\+BI G\+UI. If of length one, this family is paried with each given name. \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a group is found, and a value of 0 returns immediately if no group with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no module found in allotted time, or reference to a newly allocated module object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Module\+From\+Mac@{get\+Module\+From\+Mac}}
\index{get\+Module\+From\+Mac@{get\+Module\+From\+Mac}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Module\+From\+Mac(const Mac\+Address \&address, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getModuleFromMac(const MacAddress &address, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Module} $>$ hebi\+::\+Lookup\+::get\+Module\+From\+Mac (
\begin{DoxyParamCaption}
\item[{const {\bf Mac\+Address} \&}]{address, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_ad4078193d720554b57bfd47a46d35231}{}\label{classhebi_1_1Lookup_ad4078193d720554b57bfd47a46d35231}


Get a module with the given mac address. 

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Module}{Module} object with the given parameters. Times out after timeout\+\_\+msec milliseconds. 
\begin{DoxyParams}{Parameters}
{\em address} & Physical mac address of the given module (serves as unique id). \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a module is found, and a value of 0 returns immediately if no module with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no module found in allotted time, or reference to a newly allocated module object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!get\+Module\+From\+Name@{get\+Module\+From\+Name}}
\index{get\+Module\+From\+Name@{get\+Module\+From\+Name}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{get\+Module\+From\+Name(const std\+::string \&name, const std\+::string \&family, long timeout\+\_\+ms=\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+I\+M\+E\+O\+U\+T)}{getModuleFromName(const std::string &name, const std::string &family, long timeout_ms=DEFAULT_TIMEOUT)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf Module} $>$ hebi\+::\+Lookup\+::get\+Module\+From\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{const std\+::string \&}]{family, }
\item[{long}]{timeout\+\_\+ms = {\ttfamily DEFAULT\+\_\+TIMEOUT}}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_aaee883fe7e060f0ea0638a09bc49f54b}{}\label{classhebi_1_1Lookup_aaee883fe7e060f0ea0638a09bc49f54b}


Get a module with the given name and family. 

Blocking call which returns a reference to a \hyperlink{classhebi_1_1Module}{Module} object with the given parameters. Times out after timeout\+\_\+msec milliseconds.


\begin{DoxyParams}{Parameters}
{\em name} & The given name of the module, as viewable in the H\+E\+BI G\+UI. \\
\hline
{\em family} & The given family of the module, as viewable in the H\+E\+BI G\+UI. \\
\hline
{\em timeout\+\_\+ms} & Timeout in milliseconds. A value of -\/1 blocks until a module is found, and a value of 0 returns immediately if no module with that address is currently known by the \hyperlink{classhebi_1_1Lookup}{Lookup} class. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr with no reference if no module found in allotted time, or reference to a newly allocated module object corresponding to the given parameters otherwise. 
\end{DoxyReturn}
\index{hebi\+::\+Lookup@{hebi\+::\+Lookup}!print\+Table@{print\+Table}}
\index{print\+Table@{print\+Table}!hebi\+::\+Lookup@{hebi\+::\+Lookup}}
\subsubsection[{\texorpdfstring{print\+Table()}{printTable()}}]{\setlength{\rightskip}{0pt plus 5cm}void hebi\+::\+Lookup\+::print\+Table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classhebi_1_1Lookup_a52e3d10c45ac8b6c47a7944fee1d7189}{}\label{classhebi_1_1Lookup_a52e3d10c45ac8b6c47a7944fee1d7189}


Displays the current contents of the module registry on stdout -- i.\+e., which modules have been found by the lookup. 

\{This function is not yet part of the stable A\+PI, and is subject to change in future versions.\} 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lookup.\+hpp\item 
lookup.\+cpp\end{DoxyCompactItemize}
